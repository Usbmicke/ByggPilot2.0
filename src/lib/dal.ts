\n\'use server\';\n\nimport { getServerSession } from \'next-auth/next\';\nimport { authOptions, type EnrichedSession } from \'@/lib/config/authOptions\';\nimport { firestoreAdmin } from \'@/lib/config/firebase-admin\';\nimport { logger } from \'@/lib/logger\';\nimport { Project } from \'@/lib/types\';\n\n// =================================================================================\n// DATA ACCESS LAYER (DAL) V2.0 - Blueprint "Sektion 1.3"\n// =================================================================================\n// Denna fil är den enda i hela applikationen som tillåts kommunicera direkt med Firestore.\n// Varje funktion måste anropa `getValidatedSession` för att säkerställa att anroparen är autentiserad och auktoriserad.\n\n/**\n * Hämtar och validerar den aktuella sessionen.\n * Kastar ett fel om sessionen är ogiltig eller saknar nödvändiga ID:n.\n * @returns Den berikade och validerade sessionen.\n */\nasync function getValidatedSession(): Promise<EnrichedSession> {\n    const session = await getServerSession(authOptions);\n    if (!session?.user?.id || !session?.user?.companyId) {\n        logger.error(\'[DAL] Session validation failed\', { session });\n        throw new Error(\'Authentication required: Invalid session or missing user/company ID.\');\n    }\n    return session as EnrichedSession;\n}\n\n// --- Namespaces för DAL-funktioner ---\n\nexport const dal = {\n    /**\n     * Funktioner relaterade till projekt.\n     */\n    projects: {\n        /**\n         * Hämtar alla aktiva projekt för den inloggade användarens företag.\n         * @returns En lista med projekt.\n         */\n        async getActive(): Promise<Project[]> {\n            const session = await getValidatedSession();\n            const { companyId } = session.user;\n\n            try {\n                const projectsCollection = firestoreAdmin\n                    .collection(\'projects\')\n                    .where(\'companyId\', \'==\', companyId)\n                    // TODO: Status-logik ska förfinas enligt blueprint, detta är en startpunkt\n                    .where(\'status\', \'!=\', \'COMPLETED\');\n\n                const snapshot = await projectsCollection.get();\n                if (snapshot.empty) {\n                    return [];\n                }\n\n                const projects: Project[] = snapshot.docs.map(doc => {\n                    const data = doc.data();\n                    // Förenklad mappning för nu\n                    return {\n                        id: doc.id,\n                        projectName: data.projectName || \'Namnlöst Projekt\',\n                        clientName: data.clientName || \'Okänd Kund\',\n                        status: data.status || \'NOT_STARTED\',\n                        lastActivity: data.updatedAt?.toDate().toISOString() || new Date().toISOString(),\n                        statusColor: data.status === \'ACTIVE\' ? \'green\' : \'yellow\',\n                        progress: data.progress || 0,\n                        ...data\n                    } as Project;\n                });\n\n                logger.info(`[DAL] Fetched ${projects.length} active projects for company ${companyId}`);\n                return projects;\n\n            } catch (error) {\n                logger.error(\'[DAL] Error in projects.getActive\', { companyId, error });\n                throw new Error(\'Could not fetch active projects.\'); // Kastar fel så att anroparen kan hantera det\n            }\n        },\n\n        /**\n         * Skapar ett nytt projekt för den inloggade användarens företag.\n         * @param projectData - Datat för det nya projektet.\n         * @returns Det skapade projektets ID.\n         */\n        async create(projectData: { projectName: string; clientName: string; }): Promise<string> {\n            const session = await getValidatedSession();\n            const { userId, companyId } = session.user;\n            \n            try {\n                const newProjectRef = firestoreAdmin.collection(\'projects\').doc();\n                const newProject = {\n                    id: newProjectRef.id,\n                    ...projectData,\n                    companyId,\n                    createdBy: userId,\n                    createdAt: new Date(),\n                    updatedAt: new Date(),\n                    status: \'NOT_STARTED\',\n                    progress: 0\n                };\n\n                await newProjectRef.set(newProject);\n                logger.info(\`[DAL] Created new project "${projectData.projectName}" for company ${companyId}\`, { projectId: newProjectRef.id });\n                return newProjectRef.id;\n\n            } catch (error) {\n                logger.error(\'[DAL] Error in projects.create\', { companyId, userId, error });\n                throw new Error(\'Could not create project.\');\n            }\n        }\n    },\n\n    /**\n     * Funktioner relaterade till användare.\n     */\n    users: {\n        // Framtida funktioner som getUserProfile etc. kommer här\n    }\n\n    // Fler namespaces för customers, quotes, etc. kan läggas till här\n};\n